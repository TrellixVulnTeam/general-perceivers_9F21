<!doctype html>
<html class="no-js">
  <head><meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width,initial-scale=1"/>
    <meta name="color-scheme" content="light dark"><link rel="index" title="Index" href="../../genindex.html" /><link rel="search" title="Search" href="../../search.html" />

    <meta name="generator" content="sphinx-4.2.0, furo 2021.10.09"/>
        <title>gperc.data - gperc 0.2 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/styles/furo.css?digest=0254c309f5cadf746f1a613e7677379ac9c8cdcd" />
    <link rel="stylesheet" type="text/css" href="../../_static/styles/furo-extensions.css?digest=16fb25fabf47304eee183a5e9af80b1ba98259b1" />
    
    


<style>
  body {
    --color-code-background: #f8f8f8;
  --color-code-foreground: black;
  
  }
  body[data-theme="dark"] {
    --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
  }
  @media (prefers-color-scheme: dark) {
    body:not([data-theme="light"]) {
      --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
    }
  }
</style></head>
  <body>
    <script>
      document.body.dataset.theme = localStorage.getItem("theme") || "auto";
    </script>
    
<svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
  <symbol id="svg-toc" viewBox="0 0 24 24">
    <title>Contents</title>
    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">
      <path stroke="none" d="M0 0h24v24H0z" />
      <line x1="4" y1="6" x2="20" y2="6" />
      <line x1="10" y1="12" x2="20" y2="12" />
      <line x1="6" y1="18" x2="20" y2="18" />
    </svg>
  </symbol>
  <symbol id="svg-menu" viewBox="0 0 24 24">
    <title>Menu</title>
    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-menu">
      <line x1="3" y1="12" x2="21" y2="12"></line>
      <line x1="3" y1="6" x2="21" y2="6"></line>
      <line x1="3" y1="18" x2="21" y2="18"></line>
    </svg>
  </symbol>
  <symbol id="svg-arrow-right" viewBox="0 0 24 24">
    <title>Expand</title>
    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-chevron-right">
      <polyline points="9 18 15 12 9 6"></polyline>
    </svg>
  </symbol>
  <symbol id="svg-sun" viewBox="0 0 24 24">
    <title>Light mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="feather-sun">
      <circle cx="12" cy="12" r="5"></circle>
      <line x1="12" y1="1" x2="12" y2="3"></line>
      <line x1="12" y1="21" x2="12" y2="23"></line>
      <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
      <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
      <line x1="1" y1="12" x2="3" y2="12"></line>
      <line x1="21" y1="12" x2="23" y2="12"></line>
      <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
      <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
    </svg>
  </symbol>
  <symbol id="svg-moon" viewBox="0 0 24 24">
    <title>Dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-moon">
      <path stroke="none" d="M0 0h24v24H0z" fill="none" />
      <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z" />
    </svg>
  </symbol>
  <symbol id="svg-sun-half" viewBox="0 0 24 24">
    <title>Auto light/dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-shadow">
      <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
      <circle cx="12" cy="12" r="9" />
      <path d="M13 12h5" />
      <path d="M13 15h4" />
      <path d="M13 18h1" />
      <path d="M13 9h4" />
      <path d="M13 6h1" />
    </svg>
  </symbol>
</svg>

<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation">
<input type="checkbox" class="sidebar-toggle" name="__toc" id="__toc">
<label class="overlay sidebar-overlay" for="__navigation">
  <div class="visually-hidden">Hide navigation sidebar</div>
</label>
<label class="overlay toc-overlay" for="__toc">
  <div class="visually-hidden">Hide table of contents sidebar</div>
</label>



<div class="page">
  <header class="mobile-header">
    <div class="header-left">
      <label class="nav-overlay-icon" for="__navigation">
        <div class="visually-hidden">Toggle site navigation sidebar</div>
        <i class="icon"><svg><use href="#svg-menu"></use></svg></i>
      </label>
    </div>
    <div class="header-center">
      <a href="../../index.html"><div class="brand">gperc 0.2 documentation</div></a>
    </div>
    <div class="header-right">
      <div class="theme-toggle-container theme-toggle-header">
        <button class="theme-toggle">
          <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
          <svg class="theme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
          <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
          <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
        </button>
      </div>
      <label class="toc-overlay-icon toc-header-icon no-toc" for="__toc">
        <div class="visually-hidden">Toggle table of contents sidebar</div>
        <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
      </label>
    </div>
  </header>
  <aside class="sidebar-drawer">
    <div class="sidebar-container">
      
      <div class="sidebar-sticky"><a class="sidebar-brand" href="../../index.html">
  
  
  <span class="sidebar-brand-text">gperc 0.2 documentation</span>
  
</a><form class="sidebar-search-container" method="get" action="../../search.html" role="search">
  <input class="sidebar-search" placeholder=Search name="q" aria-label="Search">
  <input type="hidden" name="check_keywords" value="yes">
  <input type="hidden" name="area" value="default">
</form>
<div id="searchbox"></div><div class="sidebar-scroll"><div class="sidebar-tree">
  <p class="caption" role="heading"><span class="caption-text">Stories</span></p>
<ul>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../stories.html">Stories</a><input class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" role="switch" type="checkbox"/><label for="toctree-checkbox-1"><div class="visually-hidden">Toggle child pages in navigation</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../../stories.1.html">1. Quick Dopamine</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stories.2.html">2. Using CLIs (WIP)</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../remote.html">YoCo (Remote Execution)</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Documentation</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../gperc.cli.html">gperc CLI</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../gperc.configs.html">gperc Configurations</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../gperc.data.html">gperc Data</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../gperc.models.html">gperc Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../gperc.utils.html">Utils</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../testing.html">Tests</a></li>
</ul>

</div>
</div>
      </div>
      
    </div>
  </aside>
  <div class="main">
    <div class="content">
      <div class="article-container">
        <div class="content-icon-container">
          <div class="theme-toggle-container theme-toggle-content">
            <button class="theme-toggle">
              <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
              <svg class="theme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
              <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
              <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
            </button>
          </div>
          <label class="toc-overlay-icon toc-content-icon no-toc" for="__toc">
            <div class="visually-hidden">Toggle table of contents sidebar</div>
            <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
          </label>
        </div>
        <article role="main">
          <h1>Source code for gperc.data</h1><div class="highlight"><pre>
<span></span><span class="sd">"""</span>
<span class="sd">Data Reader</span>
<span class="sd">===========</span>

<span class="sd">This file has the datareaders for the ``gperc`` program. The datareaders work as follows:</span>

<span class="sd">#. The default datareader is ``gperc.BinaryConsumer`` and it reads all the files that are \</span>
<span class="sd">    provided to this. It reads the binaries of the files and reads the data based on pretty \</span>
<span class="sd">    much the size of the file.</span>
<span class="sd">#. You can provide extra metadata to the datareaders. This is done by providing a dictionary \</span>
<span class="sd">    or list. For more information read below.</span>

<span class="sd">Though there is some code added below, it does not work. I have added it here because that is</span>
<span class="sd">suppossed to be the general progression towards. The general idea is that the trainer should be</span>
<span class="sd">able to select the kind of data that it wants to use. This means that there needs to be a</span>
<span class="sd">structured way to represent and fetch the information. This is done as follows:</span>

<span class="sd">#. The input data ``F`` can be loaded in 4 different styles as given in the documentation below.</span>
<span class="sd">#. The fetching ``I`` can happen in 6 different styles as given in the documentation below.</span>

<span class="sd">I am following the same system that I have implemented in</span>
<span class="sd">`nbox.Parsers &lt;https://nimbleboxai.github.io/nbox/nbox.parsers.html&gt;`_. Here is a quick brief on</span>
<span class="sd">**primitives** ``P`` and **structures** ``S``:</span>

<span class="sd">#. ``P`` are the basic data types that are used in the data. This is the actual data \</span>
<span class="sd">    you want your model to process.</span>
<span class="sd">#. ``S`` are the structures that are used to represent the data. This is how data is organised.</span>

<span class="sd">In our day to day life, what we call data is nothing but an interplay of one ``P`` and many ``S``.</span>

<span class="sd">Raw Bytes Tokenization</span>
<span class="sd">----------------------</span>

<span class="sd">I am choosing to read binary instead of tokenizing text, this is similar to how computer programs</span>
<span class="sd">like to work.</span>

<span class="sd">1. A good way to measure the amount of information processed per sample is \</span>
<span class="sd">    ``bytes_processed = n_bytes * seqlen``, eg. ``8192 * 2 = 16KB``. ``n_bytes`` defines the total \</span>
<span class="sd">    number of tokens as ``n_tokens = 2 ** (nbytes * 8) =&gt; (256, 65536, 16777216, ...)``, which is \</span>
<span class="sd">        total number of permutations with 2 bits.</span>

<span class="sd">2. This is should not be confused with memory footprint since that is going to be larger as each \</span>
<span class="sd">    ``int`` is 64-bits (``i64`` in Rust).</span>

<span class="sd">3. In the above sample with ``batch_size = 20``, we have processed ``320KB`` same as the total \</span>
<span class="sd">    cache on `Apple M1 &lt;https://en.wikipedia.org/wiki/Apple_M1#CPU&gt;`_, which has 192 KB of L1 \</span>
<span class="sd">    instruction cache and 128 KB of L1 data cache.</span>

<span class="sd">4. Total tokens processed would be ``20 * 8192 = 163840`` in each batch and with ``i64`` that means \</span>
<span class="sd">    memory footprint of ``163840 * 64 ~ 1.25MB``.</span>

<span class="sd">5. Wrapping up that means we are processing 320KB of data in a 1.25MB memory footprint (which is a \</span>
<span class="sd">    ``4x`` memory requirement).</span>

<span class="sd">Internal Representation</span>
<span class="sd">-----------------------</span>

<span class="sd">This is what we have we have to do, ``full_meta`` is a not a good way access individual elements</span>
<span class="sd">in the batch, so we need to convert it to a more convenient internal representation. Consider</span>
<span class="sd">``full_meta`` like a table so this is what it would look like:</span>

<span class="sd">.. list-table:: Full Meta as a Table</span>
<span class="sd">   :header-rows: 1</span>

<span class="sd">   * - class</span>
<span class="sd">     - filepath</span>
<span class="sd">     - size (in bytes)</span>
<span class="sd">   * - cat</span>
<span class="sd">     - f1</span>
<span class="sd">     - 137</span>
<span class="sd">   * - cat</span>
<span class="sd">     - f2</span>
<span class="sd">     - 417</span>
<span class="sd">   * - cat</span>
<span class="sd">     - f3</span>
<span class="sd">     - 139</span>
<span class="sd">   * - dog</span>
<span class="sd">     - f4</span>
<span class="sd">     - 123</span>
<span class="sd">   * - dog</span>
<span class="sd">     - f5</span>
<span class="sd">     - 52</span>
<span class="sd">   * - dog</span>
<span class="sd">     - f6</span>
<span class="sd">     - 390</span>

<span class="sd">The batches with ``seqlen = 128`` and ``n_bytes=1`` would look like a flat array with items like this:</span>

<span class="sd">.. code-block:: python</span>
<span class="sd">    </span>
<span class="sd">    batches = [</span>
<span class="sd">        ([f1,   0, 128],),</span>
<span class="sd">        ([f1, 128, 137],</span>
<span class="sd">         [f2,   0, 119],),</span>
<span class="sd">        ([f2, 119, 347],),</span>
<span class="sd">        ([f2, 347, 417],</span>
<span class="sd">         [f3,   0,  58],),</span>
<span class="sd">        ...</span>
<span class="sd">    ]</span>

<span class="sd">Documentation</span>
<span class="sd">-------------</span>
<span class="sd">"""</span>

<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">import</span> <span class="nn">json</span>

<span class="kn">import</span> <span class="nn">torch</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="kn">from</span> <span class="nn">functools</span> <span class="k">import</span> <span class="n">lru_cache</span>
<span class="kn">from</span> <span class="nn">itertools</span> <span class="k">import</span> <span class="n">product</span>


<div class="viewcode-block" id="get_vocab"><a class="viewcode-back" href="../../gperc.data.html#gperc.data.get_vocab">[docs]</a><span class="nd">@lru_cache</span><span class="p">()</span>
<span class="k">def</span> <span class="nf">get_vocab</span><span class="p">(</span><span class="n">n_bytes</span><span class="p">):</span>
    <span class="n">B</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span> <span class="o">**</span> <span class="mi">8</span><span class="p">)</span>
    <span class="n">out</span> <span class="o">=</span> <span class="n">product</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="n">repeat</span><span class="o">=</span><span class="n">n_bytes</span><span class="p">)</span>
    <span class="n">vocab</span> <span class="o">=</span> <span class="p">{</span><span class="n">x</span><span class="p">:</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">x</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">out</span><span class="p">))}</span>
    <span class="k">return</span> <span class="n">vocab</span></div>
    


<div class="viewcode-block" id="Consumer"><a class="viewcode-back" href="../../gperc.data.html#gperc.data.Consumer">[docs]</a><span class="k">class</span> <span class="nc">Consumer</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fps</span><span class="p">,</span> <span class="n">n_bytes</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="n">seqlen</span> <span class="o">=</span> <span class="mi">1024</span><span class="p">,</span> <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">class_to_id</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">_unittesting</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">"""Consumer takes in list of files along with it's meta data and becomes a callable generator.</span>
<span class="sd">        When calling you can tell it what kind of data that you want. It is a full fledged data engine in itself.</span>
<span class="sd">        This will sit in nbox one day and thus has to be engineered in such a what that it is production grade with</span>
<span class="sd">        good documentation. In the nbox hierarchy it sits parallel to nbox.Model thus has to continue the following</span>
<span class="sd">        traits as `nbox.Parsers &lt;https://nimbleboxai.github.io/nbox/nbox.parsers.html&gt;`_:</span>

<span class="sd">        #. **primitive** that tells the actual fetching instruction</span>
<span class="sd">        #. **structure** should be same as the source meta data</span>

<span class="sd">        Args:</span>
<span class="sd">          fps (Any): The file paths have to be the primary index inside the lists and so filepaths "fps" can look like these:</span>

<span class="sd">              #. **(F0)** list of strings: ``["file1.txt", "file2.txt", ...]``</span>
<span class="sd">              #. **(F1)** list of dicts: ``[{"file1.txt": "cat1"}, {"file2.txt": "cat2"}, ...]``</span>
<span class="sd">              #. **(F2)** dict of strings: ``{"file1.txt": "cat1", "file2.txt": "cat2", ...}``</span>
<span class="sd">              #. **(F3)** dict of categories (IR): ``{"cat1": ["file1.txt", "file2.txt", ...], "cat2": ["file3.txt", "file4.txt", ...]}``</span>

<span class="sd">          batch_size (int, optional): The batch size of the data</span>
<span class="sd">          n_bytes (int, optional): number of bytes that make one token, 2 is a good number.</span>
<span class="sd">          seqlen (int, optional): the total number of tokens for each sample</span>
<span class="sd">          verbose (bool, optional): if True, prints out the progress of the data</span>
<span class="sd">          class_to_id (dict, optional): if not None, this is a dictionary that maps the class names to the integer ids.</span>
<span class="sd">          _unittesting (bool): This is a private variable that is used to test the data reader. Keep at False</span>
<span class="sd">        """</span>
        <span class="c1"># parse the fps and covert to fixed internal reprensentaion -&gt; {"meta": ["file1.txt", "file2.txt", ...]}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_mode</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fps</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fps</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">str</span><span class="p">):</span>  <span class="c1"># F0</span>
                <span class="n">fps</span> <span class="o">=</span> <span class="p">{</span><span class="s2">"null"</span><span class="p">:</span> <span class="n">fps</span><span class="p">}</span>  <span class="c1"># list of files will start with null category</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_mode</span> <span class="o">=</span> <span class="s2">"F0"</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fps</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">dict</span><span class="p">):</span>  <span class="c1"># F1</span>
                <span class="n">_fps</span> <span class="o">=</span> <span class="p">{}</span>
                <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">fps</span><span class="p">:</span>
                    <span class="n">k</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">keys</span><span class="p">())[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">v</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">values</span><span class="p">())[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">_fps</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="p">[])</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>  <span class="c1"># list of dicts will start with category as key</span>
                <span class="n">fps</span> <span class="o">=</span> <span class="n">_fps</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_mode</span> <span class="o">=</span> <span class="s2">"F1"</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">"fps is not in the correct format"</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fps</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="n">k</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="nb">iter</span><span class="p">(</span><span class="n">fps</span><span class="p">))</span>
            <span class="n">v</span> <span class="o">=</span> <span class="n">fps</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
            <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="nb">str</span><span class="p">),</span> <span class="n">f</span><span class="s2">"key has to be a string got: {type(k)}"</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>  <span class="c1"># F2</span>
                <span class="k">assert</span> <span class="nb">all</span><span class="p">([</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">_v</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="k">for</span> <span class="n">_k</span><span class="p">,</span> <span class="n">_v</span> <span class="ow">in</span> <span class="n">fps</span><span class="o">.</span><span class="n">items</span><span class="p">()]),</span> <span class="s2">"All values should be a string"</span>
                <span class="n">_fps</span> <span class="o">=</span> <span class="p">{}</span>
                <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="n">fps</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="n">_fps</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="p">[])</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
                <span class="n">fps</span> <span class="o">=</span> <span class="n">_fps</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_mode</span> <span class="o">=</span> <span class="s2">"F2"</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>  <span class="c1"># F3</span>
                <span class="c1"># this is the format we want so just perform checks</span>
                <span class="k">assert</span> <span class="nb">all</span><span class="p">([</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">_v</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="k">for</span> <span class="n">_k</span><span class="p">,</span> <span class="n">_v</span> <span class="ow">in</span> <span class="n">fps</span><span class="o">.</span><span class="n">items</span><span class="p">()]),</span> <span class="s2">"All values should be a list"</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_mode</span> <span class="o">=</span> <span class="s2">"F3"</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">f</span><span class="s2">"fps is not in the correct format: {type(fps)}"</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fps</span> <span class="o">=</span> <span class="n">fps</span>

        <span class="c1"># values set for ops</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__auto_idx</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__n_classes</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fps</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_bytes</span> <span class="o">=</span> <span class="n">n_bytes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">seqlen</span> <span class="o">=</span> <span class="n">seqlen</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">class_to_id</span> <span class="o">=</span> <span class="n">class_to_id</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">config</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">"seqlen"</span><span class="p">:</span> <span class="n">seqlen</span><span class="p">,</span>
            <span class="s2">"n_bytes"</span><span class="p">:</span> <span class="n">n_bytes</span><span class="p">,</span>
        <span class="p">}</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_unittesting</span> <span class="o">=</span> <span class="n">_unittesting</span>
        <span class="k">if</span> <span class="n">_unittesting</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="c1"># Before we get to capturing the metadata for each file it is important to understand</span>
        <span class="c1"># what is the data that we are going to get from the file. So the meta is obtained from</span>
        <span class="c1"># UNIX's sys/stat.h struct stat.</span>
        <span class="c1"># read more: https://pubs.opengroup.org/onlinepubs/000095399/basedefs/sys/stat.h.html</span>
        <span class="c1"># We are capturing the following:</span>
        <span class="c1"># - filepath: the path to the file</span>
        <span class="c1"># - extension: the extension of the file</span>
        <span class="c1"># - st_size: the size of the file in bytes</span>
        <span class="c1"># Other things that I was previously capturing but later removed:</span>
        <span class="c1"># - st_dev: Device ID of device containing file, st_ino: File serial number</span>
        <span class="c1"># (st_dev, st_ino) is unique to each file and thus can be used to identify the file</span>
        <span class="c1"># - times: not relevant (TODO: @yashbonde -&gt; Casual models)</span>
        <span class="c1"># - blk_size and blk_count: size of the blocks and the number of blocks</span>
        <span class="n">meta</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">_c</span><span class="p">,</span> <span class="n">files</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">fps</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">_meta_for_class</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s2">"filepath"</span><span class="p">:</span> <span class="p">[],</span>
                <span class="s2">"extensions"</span><span class="p">:</span> <span class="p">[],</span>
                <span class="s2">"st_size"</span><span class="p">:</span> <span class="p">[],</span>
            <span class="p">}</span>
            <span class="k">for</span> <span class="n">_f</span> <span class="ow">in</span> <span class="n">files</span><span class="p">:</span>
                <span class="n">s</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">stat</span><span class="p">(</span><span class="n">_f</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">_meta_for_class</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">_meta_for_class</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">k</span><span class="p">))</span>
                    <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                        <span class="k">pass</span>
                <span class="n">_meta_for_class</span><span class="p">[</span><span class="s2">"filepath"</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">_f</span><span class="p">)</span>
                <span class="n">ext</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="n">_f</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">_meta_for_class</span><span class="p">[</span><span class="s2">"extensions"</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ext</span><span class="p">)</span>

            <span class="n">meta</span><span class="p">[</span><span class="n">_c</span><span class="p">]</span> <span class="o">=</span> <span class="n">_meta_for_class</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">full_meta</span> <span class="o">=</span> <span class="n">meta</span>

        <span class="c1"># Next we must create a samples of data and create the one true location of each item in the</span>
        <span class="c1"># batch. This will help up locate and read things faster.</span>
        <span class="k">for</span> <span class="n">_c</span><span class="p">,</span> <span class="n">_meta</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">full_meta</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">_cumm_sizes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">_meta</span><span class="p">[</span><span class="s2">"st_size"</span><span class="p">])</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
            <span class="n">total_size</span> <span class="o">=</span> <span class="n">_cumm_sizes</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">total_tokens</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">total_size</span> <span class="o">/</span> <span class="n">n_bytes</span><span class="p">)</span>
            <span class="n">total_samples</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">total_tokens</span> <span class="o">/</span> <span class="n">seqlen</span><span class="p">)</span>
            <span class="n">meta</span><span class="p">[</span><span class="n">_c</span><span class="p">]</span><span class="o">.</span><span class="n">update</span><span class="p">({</span>
                <span class="s2">"cummulative"</span><span class="p">:</span> <span class="n">_cumm_sizes</span><span class="p">,</span>
                <span class="s2">"total_tokens"</span><span class="p">:</span> <span class="n">total_tokens</span><span class="p">,</span>
                <span class="s2">"total_samples"</span><span class="p">:</span> <span class="n">total_samples</span><span class="p">,</span>
            <span class="p">})</span>

        <span class="c1"># Now we create the samples by reading going over file sizes and creating the samples</span>
        <span class="c1"># seqlen_sample_in_bytes = seqlen * n_bytes</span>
        <span class="c1"># each sample is a tuple of the following items (_class, filepath, seek, read_size)</span>
        <span class="n">all_samples</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">req_size</span> <span class="o">=</span> <span class="n">seqlen</span> <span class="o">*</span> <span class="n">n_bytes</span>
        <span class="k">for</span> <span class="n">_c</span><span class="p">,</span> <span class="n">_meta</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">full_meta</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="c1"># ----- for each label</span>
            <span class="n">sizes</span> <span class="o">=</span> <span class="n">_meta</span><span class="p">[</span><span class="s2">"st_size"</span><span class="p">]</span>
            <span class="n">filepath</span> <span class="o">=</span> <span class="n">_meta</span><span class="p">[</span><span class="s2">"filepath"</span><span class="p">]</span>
            <span class="n">_f_idx</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">_curr_size</span> <span class="o">=</span> <span class="n">sizes</span><span class="p">[</span><span class="n">_f_idx</span><span class="p">]</span>
            <span class="n">_curr_seek</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">while</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">sample</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">total_bytes</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">while</span> <span class="n">total_bytes</span> <span class="o">&lt;</span> <span class="n">req_size</span><span class="p">:</span>
                    <span class="n">_remaining_bytes_in_file</span> <span class="o">=</span> <span class="n">_curr_size</span> <span class="o">-</span> <span class="n">_curr_seek</span>
                    <span class="n">_remaining_bytes_in_sample</span> <span class="o">=</span> <span class="n">req_size</span> <span class="o">-</span> <span class="n">total_bytes</span>
                    <span class="k">if</span> <span class="n">_remaining_bytes_in_sample</span> <span class="o">&gt;</span> <span class="n">_remaining_bytes_in_file</span><span class="p">:</span>
                        <span class="c1"># add data for this sample and then move to next file</span>
                        <span class="n">sample</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">filepath</span><span class="p">[</span><span class="n">_f_idx</span><span class="p">],</span> <span class="n">_curr_seek</span><span class="p">,</span> <span class="n">_curr_size</span><span class="p">))</span>
                        <span class="n">_f_idx</span> <span class="o">+=</span> <span class="mi">1</span>
                        <span class="n">total_bytes</span> <span class="o">+=</span> <span class="p">(</span><span class="n">sample</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">sample</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span>
                        <span class="k">if</span> <span class="n">_f_idx</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">filepath</span><span class="p">):</span>
                            <span class="k">break</span>
                        <span class="n">_curr_size</span> <span class="o">=</span> <span class="n">sizes</span><span class="p">[</span><span class="n">_f_idx</span><span class="p">]</span>
                        <span class="n">_curr_seek</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">sample</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">filepath</span><span class="p">[</span><span class="n">_f_idx</span><span class="p">],</span> <span class="n">_curr_seek</span><span class="p">,</span> <span class="n">_curr_seek</span> <span class="o">+</span> <span class="n">_remaining_bytes_in_sample</span><span class="p">))</span>
                        <span class="n">_curr_seek</span> <span class="o">+=</span> <span class="n">_remaining_bytes_in_sample</span>
                        <span class="n">total_bytes</span> <span class="o">+=</span> <span class="p">(</span><span class="n">sample</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">sample</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span>
                    
                <span class="n">all_samples</span><span class="o">.</span><span class="n">append</span><span class="p">({</span>
                    <span class="s2">"data"</span><span class="p">:</span> <span class="n">sample</span><span class="p">,</span>
                    <span class="s2">"class"</span><span class="p">:</span> <span class="n">_c</span><span class="p">,</span>
                <span class="p">})</span>

                <span class="k">if</span> <span class="n">_f_idx</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">filepath</span><span class="p">):</span>
                    <span class="k">break</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">all_samples</span> <span class="o">=</span> <span class="n">all_samples</span>

        <span class="c1"># For ensuring guarantees, we need to check if the total number of samples is same as from</span>
        <span class="c1"># the meta.</span>
        <span class="k">assert</span> <span class="nb">sum</span><span class="p">([</span><span class="n">_meta</span><span class="p">[</span><span class="s2">"total_samples"</span><span class="p">]</span> <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">_meta</span> <span class="ow">in</span> <span class="n">meta</span><span class="o">.</span><span class="n">items</span><span class="p">()])</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">all_samples</span><span class="p">),</span> \
            <span class="s2">"total samples through both approaches are not the same: got </span><span class="si">{}</span><span class="s2"> and </span><span class="si">{}</span><span class="s2">"</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="nb">sum</span><span class="p">([</span><span class="n">_meta</span><span class="p">[</span><span class="s2">"total_samples"</span><span class="p">]</span> <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">_meta</span> <span class="ow">in</span> <span class="n">meta</span><span class="o">.</span><span class="n">items</span><span class="p">()]),</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">all_samples</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_total_samples</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">all_samples</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">samples_by_class</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_samples</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">samples_by_class</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="s2">"class"</span><span class="p">],</span> <span class="p">[])</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

        <span class="c1"># finally the dataset is ready, if verbose print the stats</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">"="</span> <span class="o">*</span> <span class="mi">50</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">"Loading complete:"</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">all_samples</span><span class="p">))</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">"Breakdown by class:"</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">samples_by_class</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="s2">"  </span><span class="si">{k}</span><span class="s2">: {len(v)} ({len(v)/self._total_samples * 100:.3f}%)"</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">"="</span> <span class="o">*</span> <span class="mi">50</span><span class="p">)</span>

    <span class="c1"># ----- functions for pretty printing and handling of dataset object.</span>

<div class="viewcode-block" id="Consumer.get_dict"><a class="viewcode-back" href="../../gperc.data.html#gperc.data.Consumer.get_dict">[docs]</a>    <span class="k">def</span> <span class="nf">get_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">_d</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">"total_samples"</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_total_samples</span><span class="p">,</span>
            <span class="s2">"batch_size"</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s2">"batch_size"</span><span class="p">],</span>
            <span class="s2">"mode"</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mode</span><span class="p">,</span>
            <span class="s2">"n_classes"</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">__n_classes</span><span class="p">,</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="n">_d</span><span class="p">[</span><span class="s2">"batch_size"</span><span class="p">]</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">_d</span><span class="p">[</span><span class="s2">"total_batches"</span><span class="p">]</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_total_samples</span> <span class="o">/</span> <span class="n">_d</span><span class="p">[</span><span class="s2">"batch_size"</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">_d</span></div>

<div class="viewcode-block" id="Consumer.to_json"><a class="viewcode-back" href="../../gperc.data.html#gperc.data.Consumer.to_json">[docs]</a>    <span class="k">def</span> <span class="nf">to_json</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_dict</span><span class="p">(),</span> <span class="n">indent</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">f</span><span class="s2">"&lt;gperc Consumer {self.to_json()}&gt;"</span>

    <span class="k">def</span> <span class="nf">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_total_samples</span>

    <span class="c1"># ----- the most important function</span>

<div class="viewcode-block" id="Consumer.__getitem__"><a class="viewcode-back" href="../../gperc.data.html#gperc.data.Consumer.__getitem__">[docs]</a>    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">"""This is the heart of this code, it takes in user requests and returns the data according to it. This is slightly</span>
<span class="sd">        technical and so we will explain it in detail. I find similarities between databases in CRUD and datasets for machine</span>
<span class="sd">        learning, CRUD has amazing performance and interaction tools like SQL. Datasets in ML are more like a collection of</span>
<span class="sd">        data, and they are not designed to be used in friendly way. Everyone's writing their own thing there but good UX requires</span>
<span class="sd">        satisfying the user in some kind of formula and then let them be.</span>

<span class="sd">        Any SQL query has the following grammar ``SELECT [columns] FROM [table] WHERE [condition]``. This is something everyone</span>
<span class="sd">        understands, it's very simple. In our case ``[table] == self``, i.e. the table is the dataset itself, this is no RDMS.</span>
<span class="sd">        The condition is very clearly desctibed in the documentation of ``x``. But ``[columns]`` (here calling it ``query``) is</span>
<span class="sd">        something hard, ie. user needs something in a particular format, and with random user logic is hard to give guarantees.</span>
<span class="sd">        I will come back to this later.</span>

<span class="sd">        The ``condition``, has two parts, the ``primitive`` and ``structure``. With this version of the code, the ``structure``</span>
<span class="sd">        and ``primitive`` are implemented in pythonic way. Read the documentation of ``x`` for more details. After getting the data</span>
<span class="sd">        we convert it to an intermediate format, which is a list of tuples, each tuple is a sample. The intermediate format has the</span>
<span class="sd">        can be one of the following:</span>
<span class="sd">            </span>
<span class="sd">        1. dict like this:</span>
<span class="sd">        </span>
<span class="sd">        .. code-block:: python</span>

<span class="sd">            {</span>
<span class="sd">                'data': [</span>
<span class="sd">                    ('some/file/1', seek_location, end_bytes),</span>
<span class="sd">                    # &gt;= 1 sample of the above tuple</span>
<span class="sd">            ],</span>
<span class="sd">                'class': 'tinker'</span>
<span class="sd">            }</span>
<span class="sd">    </span>
<span class="sd">        2.  list with dict in it, in which case the samples are batched together.</span>

<span class="sd">        The intermediate format is then converted to the desired format i.e. ``query``, currently I have added functionality that</span>
<span class="sd">        can return one of the following formats:</span>

<span class="sd">        1. ``supervised``, in which input is the input tensor and output is the class tensor, from ``self.class_to_id`` dict.</span>
<span class="sd">        2. ``unsupervised``, in which input is the input tensor and output is clone of it.</span>


<span class="sd">        Args:</span>

<span class="sd">            x(Any): There is only one input since this is a special method. We take in this input item and process it accordingly</span>
<span class="sd">                based on following rules:</span>

<span class="sd">                1. **(I0)** ``None``: when x is None we have an internal idx that is incremented and the next batch is returned</span>
<span class="sd">                2. **(I1)** ``int``: when x is an int we return the batch at that index</span>
<span class="sd">                3. **(I2)** ``slice``: when x is a slice we return the batches in the slice</span>
<span class="sd">                4. **(I3)** ``list``: when x is a list we return the batches in the list containing the indices (``int``)</span>
<span class="sd">                5. **(I4)** ``dict -&gt; ints``: when values of x are ints we return the batches in the list containing the indices (``int``)</span>
<span class="sd">                6. **(I5)** ``dict -&gt; list``: when values of x are lists we return the batches in the list containing the indices (``list``)</span>
<span class="sd">                7. **(I6)** ``tuple``: Read below.</span>

<span class="sd">            x_tuple(Tuple): When x is a tuple you can use it like a function, meaning it can run certain hardcoded logic. It should</span>
<span class="sd">                have  ``condition`` as above and ``query``. This is not a real input, added seperately for documentation convinience.</span>
<span class="sd">                The object ``query`` can be one of the following</span>
<span class="sd">                </span>
<span class="sd">                1. ``None``: returns just ``{"input_tensor": tensor}`` dict</span>
<span class="sd">                    2. ``'supervised'``: ``{"input_tensor": tensor, "class": tensor}``, this will fail if incorrect ``self.class_to_id``</span>
<span class="sd">                3. ``'unsupervised'``: ``{"input_tensor": tensor, "output_tensor": tensor}``</span>

<span class="sd">        Using this is very simple.</span>

<span class="sd">        .. code-block:: python</span>

<span class="sd">            # define the consumer object</span>
<span class="sd">            my_kewl_dataset = Consumer(</span>
<span class="sd">                fps = {</span>
<span class="sd">                    "cat": ["img0.png", "/tmp/ssg3hng.png", ...],</span>
<span class="sd">                    "dog": ["img1.png", "/tmp/uo35523.png", ...],</span>
<span class="sd">                },</span>
<span class="sd">                seed = 4</span>
<span class="sd">            )</span>

<span class="sd">            # output in all cases is a batched tensor of desired shape</span>
<span class="sd">            out = my_kewl_dataset[None] # get whatever is the next batch</span>
<span class="sd">            out = my_kewl_dataset[0]    # get the data at index 0</span>
<span class="sd">            out = my_kewl_dataset[5:10] # get the data at indices 5 to 10</span>
<span class="sd">            out = my_kewl_dataset[{</span>
<span class="sd">                "cat": 10,</span>
<span class="sd">                "dog": 4</span>
<span class="sd">            }] # return random batches of 10 samples from class cat and 4 samples from class dog</span>
<span class="sd">            out = my_kewl_dataset[{</span>
<span class="sd">                "cat": [0, 1, 2, 3, 4],</span>
<span class="sd">                "dog": [5, 6, 7, 8, 9]</span>
<span class="sd">            }] # return the batches at indices [0...4] and [5...9] from class cat and class dog respectively</span>
<span class="sd">        """</span>
        <span class="c1"># check if case I6 and create necessary variables</span>
        <span class="n">data_dict</span> <span class="o">=</span> <span class="p">{</span><span class="s2">"input_tensor"</span><span class="p">:</span> <span class="kc">None</span><span class="p">}</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">and</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">"supervised"</span><span class="p">,</span> <span class="s2">"unsupervised"</span><span class="p">],</span> \
                        <span class="s2">"case I6: second argument must be None or 'supervised' or 'unsupervised'"</span>
                    <span class="k">if</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s2">"supervised"</span><span class="p">:</span>
                        <span class="n">data_dict</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s2">"class"</span><span class="p">:</span> <span class="kc">None</span><span class="p">})</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">data_dict</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s2">"output_tensor"</span><span class="p">:</span> <span class="kc">None</span><span class="p">})</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># testing requires conditional data</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_unittesting</span><span class="p">:</span>
            <span class="n">all_samples</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fps</span><span class="o">.</span><span class="n">values</span><span class="p">())[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">sample_by_class</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fps</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">all_samples</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_samples</span>
            <span class="n">sample_by_class</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">samples_by_class</span>


        <span class="c1"># fetching based on a bunch of different indexing methods</span>
        <span class="k">if</span> <span class="n">x</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># i0</span>
            <span class="n">batch_data</span> <span class="o">=</span> <span class="n">all_samples</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">__auto_idx</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__auto_idx</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>  <span class="c1"># i1</span>
            <span class="n">batch_data</span> <span class="o">=</span> <span class="n">all_samples</span><span class="p">[</span><span class="n">x</span><span class="p">]</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="nb">slice</span><span class="p">):</span>  <span class="c1"># i2</span>
            <span class="n">batch_data</span> <span class="o">=</span> <span class="n">all_samples</span><span class="p">[</span><span class="n">x</span><span class="p">]</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>  <span class="c1"># i3</span>
            <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">int</span><span class="p">),</span> <span class="n">f</span><span class="s2">"Items in list must be integers"</span>
            <span class="n">batch_data</span> <span class="o">=</span> <span class="p">[</span><span class="n">all_samples</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">x</span><span class="p">]</span>
        
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fps</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="s2">"null"</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">fps</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">"There is no category provided, so you cannot try to make a batch from a dict"</span><span class="p">)</span>
            <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">values</span><span class="p">())[</span><span class="mi">0</span><span class="p">],</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">list</span><span class="p">)),</span> <span class="n">f</span><span class="s2">"Values in dict must be integers or lists"</span>
            <span class="n">keys_in_x_not_in_fps</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fps</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>
            <span class="k">assert</span> <span class="n">keys_in_x_not_in_fps</span> <span class="o">==</span> <span class="nb">set</span><span class="p">(),</span> <span class="n">f</span><span class="s2">"Keys in dict must be in fps: </span><span class="si">{keys_in_x_not_in_fps}</span><span class="s2">"</span>
            <span class="n">batch_data</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">x</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">samples</span> <span class="o">=</span> <span class="n">sample_by_class</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>  <span class="c1"># i4</span>
                    <span class="k">assert</span> <span class="n">v</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="n">f</span><span class="s2">"Values in dict must be positive integers"</span>
                    <span class="n">batch_data</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">samples</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>
                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>  <span class="c1"># i5</span>
                    <span class="n">batch_data</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">samples</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">v</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="n">f</span><span class="s2">"Invalid input type: {type(x)}"</span><span class="p">)</span>

        <span class="c1"># if testing return</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_unittesting</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">batch_data</span>

        <span class="c1"># Next we take the samples and we read the data</span>
        <span class="k">def</span> <span class="nf">__get_one_sample</span><span class="p">(</span><span class="n">sample</span><span class="p">):</span>
            <span class="n">files</span> <span class="o">=</span> <span class="n">sample</span><span class="p">[</span><span class="s2">"data"</span><span class="p">]</span>
            <span class="n">_class</span> <span class="o">=</span> <span class="n">sample</span><span class="p">[</span><span class="s2">"class"</span><span class="p">]</span>
            <span class="n">sample</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">f</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">files</span><span class="p">:</span>
                <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s2">"rb"</span><span class="p">)</span> <span class="k">as</span> <span class="n">fp</span><span class="p">:</span>
                    <span class="n">fp</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
                    <span class="nb">bytes</span> <span class="o">=</span> <span class="n">fp</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">e</span> <span class="o">-</span> <span class="n">s</span><span class="p">)</span>
                    <span class="n">sample</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="nb">bytes</span><span class="p">)</span>

            <span class="n">sample</span> <span class="o">=</span> <span class="p">[(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">sample</span><span class="p">[::</span><span class="mi">2</span><span class="p">],</span> <span class="n">sample</span><span class="p">[</span><span class="mi">1</span><span class="p">::</span><span class="mi">2</span><span class="p">])]</span>
            <span class="n">vocab</span> <span class="o">=</span> <span class="n">get_vocab</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_bytes</span><span class="p">)</span>
            <span class="n">seq</span> <span class="o">=</span> <span class="p">[</span><span class="n">vocab</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">sample</span><span class="p">]</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">seq</span><span class="p">)</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">seqlen</span><span class="p">:</span>
                <span class="n">seq</span> <span class="o">+=</span> <span class="p">[</span><span class="n">vocab</span><span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">seqlen</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">seq</span><span class="p">))]</span>
            
            <span class="k">return</span> <span class="n">seq</span><span class="p">,</span> <span class="n">_class</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">batch_data</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">data</span> <span class="o">=</span> <span class="p">[</span><span class="n">__get_one_sample</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">batch_data</span><span class="p">]</span>
            <span class="n">seq</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">data</span><span class="p">]</span>
            <span class="n">labels</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">data</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">__get_one_sample</span><span class="p">(</span><span class="n">batch_data</span><span class="p">)</span>
            <span class="n">seq</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
            <span class="n">labels</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>

        <span class="n">out</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">long</span><span class="p">)</span>

        <span class="c1"># now we take the data structure it according to the user's request</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">data_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="s2">"input_tensor"</span><span class="p">:</span>
                <span class="n">data_dict</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">out</span>
            <span class="k">elif</span> <span class="n">k</span> <span class="o">==</span> <span class="s2">"output_tensor"</span><span class="p">:</span>
                <span class="n">data_dict</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">out</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span>
            <span class="k">elif</span> <span class="n">k</span> <span class="o">==</span> <span class="s2">"class"</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">class_to_id</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
                    <span class="n">class_tensor</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">class_to_id</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">labels</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">"class_to_id dict must be a provided"</span><span class="p">)</span>
                <span class="n">data_dict</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">class_tensor</span><span class="p">)</span><span class="o">.</span><span class="n">long</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">data_dict</span></div></div>
</pre></div>
        </article>
      </div>
      <footer>
        
        <div class="related-pages">
          
          
        </div>

        <div class="related-information">
              Copyright &#169; 2021, Yash Bonde |
            Built with <a href="https://www.sphinx-doc.org/">Sphinx</a>
              and
              <a class="muted-link" href="https://pradyunsg.me">@pradyunsg</a>'s
              <a href="https://github.com/pradyunsg/furo">Furo theme</a>.
        </div>
        
      </footer>
    </div>
    <aside class="toc-drawer no-toc">
      
      
      
    </aside>
  </div>
</div><script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/scripts/main.js"></script>
    </body>
</html>